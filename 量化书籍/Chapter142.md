# 量化实战入门142—揭开阿尔法与贝塔的秘密 

阿尔法（Alpha）和贝塔（Beta）是金融领域中常用的两个术语，它们在投资和资产定价模型中扮演着重要的角色。

## 一、什么是贝塔


贝塔则是衡量个别资产或投资组合相对于整体市场波动的指标，它是资本资产定价模型（Capital Asset Pricing Model, CAPM）中的核心概念。贝塔衡量的是资产的系统风险，也就是与市场整体变动相关的风险。
不同的贝塔值揭示了资产或投资组合与市场波动的关系，具体如下：
### 1. 贝塔等于1
贝塔值为1意味着资产或投资组合的价格波动与市场整体波动是同步的。当市场上涨时，这类资产或组合预期也会相应上涨；反之，当市场下跌时，它们也会下跌。贝塔等于1通常表示资产或投资组合具有平均的市场风险。
### 2. 贝塔大于1
当贝塔值大于1时，资产或投资组合的价格波动与市场同向，但比市场更加剧烈。这意味着如果市场上涨，这类资产或组合的预期回报将超过市场平均水平；而在市场下跌时，它们的损失也可能会更严重。贝塔大于1表示资产或投资组合具有较高的市场风险，适合那些能够承受较高波动并寻求更高回报的投资者。
### 3. 贝塔小于1但大于0
贝塔值在0到1之间表明资产或投资组合的价格波动小于市场。这类资产在市场上涨时可能会有较小的回报，而在市场下跌时损失也相对有限。贝塔小于1但大于0通常表示资产或投资组合具有低于平均水平的市场风险，适合风险厌恶型投资者。
### 4. 贝塔等于0
贝塔值为0意味着资产或投资组合的回报与市场波动没有关联。换言之，这类资产的回报不受市场整体波动的影响。这可能发生在固定收益投资中，它们与市场走势不同步。
### 5. 贝塔为负值
贝塔值为负意味着资产或投资组合的表现与市场走势相反。如果市场上涨，这类资产的价格可能会下跌；反之，则可能上涨。具有负贝塔的资产可以作为投资组合的对冲工具，因为它们提供了负相关性，有助于在市场下跌时减少损失。

理解贝塔值对于投资者来说非常重要，因为它帮助他们根据自己的风险承受能力和投资目标来选择合适的资产和构建投资组合。例如，风险厌恶型投资者可能倾向于选择贝塔低于1的资产，而风险追求型投资者可能会寻找贝塔大于1的投资机会。
## 二、什么是阿尔法
阿尔法是衡量一个投资组合相对于基准表现的指标，它代表了投资组合的超额回报。换句话说，阿尔法是投资组合实际回报与根据其贝塔所预期的回报之间的差额。如果一个投资组合有正阿尔法，这意味着它在调整风险之后，表现优于基准指数；如果阿尔法是负的，那么投资组合就是在跑输基准指数。

阿尔法的值在不同的情况下有不同的含义，具体如下：
### 1. 阿尔法为正值
当投资组合的阿尔法为正时，这意味着投资组合在调整了市场风险后，实现了超过基准的回报。例如，一个阿尔法值为+3%的投资组合表明它在考虑了其市场风险贝塔后，比基准表现好3个百分点。正阿尔法通常被解释为投资经理的选股能力、市场时机选择能力或其他投资策略的成功实践，这些能力使得投资组合的表现超越了市场平均水平。
### 2. 阿尔法为零
当投资组合的阿尔法为零时，这表示该组合的表现与其市场风险贝塔所预期的回报完全一致。换句话说，投资组合没有实现超额回报，也没有表现不及基准。在这种情况下，投资者可能会认为投资这个组合没有获取到额外的价值，因为它的表现仅仅是跟随了市场。
### 3. 阿尔法为负值
如果投资组合的阿尔法为负，这表示在调整了市场风险之后，投资组合的表现低于基准指数。例如，一个阿尔法值为-2%的投资组合意味着它在考虑其贝塔风险后，实际回报低于基准回报2个百分点。负阿尔法可能表明投资经理的选股或市场时机选择策略未能成功，或者投资策略本身存在缺陷，导致投资组合表现不佳。
## 三、如何计算阿尔法和贝塔

阿尔法和贝塔的计算通常有"回归法"和"协方差/方差法”，举例说明如下：
### 1. 获取标的股票和基准的基础数据
我们从AKShare数据源获取沪深300指数和山西汾酒的收盘价数据，并以沪深300指数作为基准指数（代表市场）。AKShare的接口有时会有更新，如果提示接口不存在，请参考AKShare的网站。

```python 

# 导入需要使用的库
import akshare as ak
import pandas as pd
import numpy as np
# 关闭警告信息
import warnings
warnings.filterwarnings('ignore')

# 设置取数日期范围
start_date = '20140101'
end_date = '20231229'
# 获取基准指数的收盘价数据
benchmark = "000300"
bars = ak.stock_zh_index_hist_csindex(symbol=benchmark, start_date=start_date, end_date=end_date)
# 将日期设置为datetime格式
bars['日期'] = pd.to_datetime(bars['日期'])
prices_df = pd.DataFrame(index=bars['日期'])
prices_df[f'{benchmark}'] = bars.set_index('日期')['收盘']

# 获取股票的收盘价数据
stock = "600809"
bars = ak.stock_zh_a_hist(symbol=stock, period="daily", start_date=start_date, end_date=end_date, adjust="qfq")
# 将日期设置为datetime格式
bars['日期'] = pd.to_datetime(bars['日期'])
prices_df[f'{stock}'] = bars.set_index('日期')['收盘']
```

### 2. 用回归法计算阿尔法和贝塔值
回归法是参照资本资产定价模型（CAPM）建立回归方程，CAPM模型表述了预期回报与市场风险之间的关系，其公式为：

         Rp = Rf + βi * (Rm - Rf)


其中：


Rp=资产收益率


Rm=市场收益率


Rf=无风险利率


βi=资产beta值

我们可以通过线性回归分析历史数据来估算贝塔值，具体如下：

```python 

# 用回归法计算阿尔法和贝塔，假设无风险报酬率为0
# 导入需要的库
import statsmodels.api as sm

# 年化期数，一年约244个交易日
annual_periods = 244  
# 计算基准和标的股票的日收益率
returns = prices_df.pct_change().fillna(0)

# 为线性回归的自变量（市场的回报率）添加常数项
X = sm.add_constant(returns[f'{benchmark}'])
# 运行回归分析
model = sm.OLS(returns[f'{stock}'], X).fit()
# 贝塔值是市场回报率的回归系数
beta = model.params[f'{benchmark}']
# 阿尔法值是回归截距，乘以年化期数进行简单年化处理
alpha = model.params['const'] * annual_periods

print(alpha, beta)

```

线性回归模型通常包括一个截距项（常数项），在上述代码中sm.add_constant函数用于向自变量（市场的回报率）中添加这个常数项。


使用statsmodels库中的OLS类，我们将资产回报率作为因变量（y），市场回报率和常数项作为自变量（X），进行普通最小二乘回归（OLS）分析。


求解回归模型得到回归系数，对应于市场回报率的系数就是我们要求的贝塔值，回归结果中的截距项即为阿尔法值。
### 3. 用协方差 / 方差法计算阿尔法和贝塔值
贝塔值可以通过计算资产回报率与市场回报率之间的协方差，然后除以市场回报率的方差来得到，即：

            Beta = Cov(R_asset, R_market) / Var(R_market)

其中：


Cov(R_asset, R_market)为资产回报率与市场回报率协方差
Var(R_market)为市场回报率的方差

计算出贝塔后，可以用以下公式计算阿尔法：

      Alpha = Rp − [Rf + βi * (Rm − Rf)]


其中：


Rp=资产收益率


Rm=市场收益率


Rf=无风险利率


βi=资产beta值

代码如下：

```python 


# 用协方差 / 方差法计算阿尔法和贝塔值，假设无风险报酬率为0
# 年化期数，一年约244个交易日
annual_periods = 244  
# 计算基准和标的股票的日收益率
returns = prices_df.pct_change().fillna(0)

# 计算returns和benchmark的协方差矩阵，这个矩阵包含了两个序列的方差和协方差
matrix = np.cov(returns[f'{stock}'], returns[f'{benchmark}'])
# 贝塔 = 资产回报率与基准回报率之间的协方差 / 基准回报率的方差
beta = matrix[0, 1] / matrix[1, 1]
# 阿尔法 = 资产回报率均值 - 贝塔 * 基准回报率均值
alpha = returns[f'{stock}'].mean() - beta * returns[f'{benchmark}'].mean()
# 乘以年化期数进行简单年化处理
alpha = alpha * annual_periods

print(alpha, beta)

```

上述代码使用numpy库中的cov函数计算returns和benchmark的协方差矩阵。这个矩阵是一个2x2的矩阵，其中包含了两个序列的方差和协方差。


贝塔值是协方差矩阵中投资组合回报率与基准回报率协方差（matrix[0, 1]）除以基准回报率的方差（matrix[1, 1]）得到的。


用资产回报率的均值减去市场回报率均值与贝塔值的乘积，即可得到阿尔法值。


"回归法"和"协方差/方差法”得到的计算结果是相同的。